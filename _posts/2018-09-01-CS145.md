---
layout: post
title: CS 145
term: 1189
subject: cs
hide: true
feature_image: "https://picsum.photos/2560/600?image=875"
feature_text: |
    <h2 style="color:white;"> Intro to more Racket </h2>
---

 > I was auditing this course during this term.

As I mentioned briefly in [cs 135](/17-09/CS135/), how this course looks like. Here I will say sth more.

The course covers so many topics like:
- basic CS 135
- lambda calculus (including Y-combinator)
- stream (lazy calculation: representing infinite sequence)
- CPU (RAM implementation and so on)

Much more abstract and 'useful' (if you study programming language theory). Assignments are more challenging as well.

After several weeks of lectures, I found I couldn't learn anything without doing assignments... Below is my partial notes for several weeks' lectures.

---

## Lec0

 Nothing special

## Lec1

 ```lisp
 (define (sum a b)
     (+ a b))
 (sum (sum 10 20) (sum (20 30)))
 (if true 1 2)
 (if false 1 2)
 (define (mymax x y)  ;; this function takes max
     (if (> x y) x y))
 ;; sum integers from 1 to n
 (+ 1 2 ... n)
 (define sumto0 0)
 (define sumto1 (+ 1 sumto0))
 (define sumto2 (+ 2 sumto1))
 ...
 (define sumtoN (+ N sumtoN-1))
 ;;*******************************************
 (define (sumto N)
     (if (= N 0) 0
         (if (= N 1) (+ 1 (sumto 0))
             (if (= N 2) (+ 2 (sumto 1)) 999))))
 ;;*******************
 (define (sumto N)
     (if (= N 0) 0
         (if (= N 1) (+ 1 (sumto 0))
             (if (= N 2) (+ 2 (sumto 1))
                 (+ N (sumto (- N 1)))))))
 ;;***********************
 (define (sumto N)
     (if (= N 0) 0
         (+ N (sumto (sub1 N)))))
 ;; **********************************
 (define (sumto N)
     (sumbetween 1 N 0))
 ;; compute acc + sum from a through b
 (define (sumbetween a b acc)
     (if (> a b) acc
         (sumbetween (+ 1 a) b (+ acc a))))
 ;; *******************************
 (define (sumTo N)
     (/ (* N (+ N 1)) 2))
 ```

## Lec 2

 ```lisp
 (cond [true 2]
 	  [false 1])
 ```

### structures

 Like functions, constructor instead of function

 ​			selectors, predict

 ```lisp
 (define-struct twosimp (one two))

 (make-twosimp 'bart 'homer)

 (define (hasbart b)
     (cond
         [(symbol? b) (symbol=? b 'bart)]
     	[(twosimp? b) (or (hadbart (twosimp-x b))
                           (hadbart (twosimp-y b)))]
 		[else false]))

 ```

## Lec whatever

 Data structures

 "structs" are just building tricks.

 data structure = call, house, castle built from building blocks + other studs according to the rules. Set of rules called "invariant".

 ``` lisp
 (define-struct pair (a b))
 ;; "bunch of numbers"
 ;; one of :
 ;; "empty bunch" empty
 ;; "singleton" 	number
 ;; general (make-pair x y)
 ;; where x and y are non-empty bunches
 (bunch? empty) ; true
 (bunch? 'hello) ; false
 (bunch? (make-pair 10 20)) ;true
 (bunch? (make-pair 10 empty)) ;false
 (define q ...)
 (define r ...)
 (bunch? (make-pair q r)) ; depend on q r

 ;; (bunch? x) yields true if x is a bunch of numbers
 (define (bunch? b)
     (cond
         [(empty? b) true]
     	[(number? b) true]
 		[(and (make-pair? b)
               (not (empty? (pair-a b)))
               (not (empty? (pair-b b)))
               (bunch? (pair-a b))
               (bunch? (pair-b b))) true]
 		[true false]))
 ```

 ```
 size of bunch   | (bunch? ) correct
 ----------------+-------------------
 0				| :)
 1				| :)
 2				| :)
 3				| :)
 4				| complicated,
 so we use box+pointer notation
 ```

 Abbreviated notation.

 ```
        .
 	   / \
 	  /\ /\
 ```

 ```lisp
 ;; create bunch with all elements of bunch b plus n
 ;; assume n is number
 (define
     (bunch-add-num b n)
     	(cond
             [(empty? b) n]
     		[(#t (make-pair b n))]))
 ;; create bunch with all elements of bunches b1 and b2
 (define (bunch-add-bunch b1 b2)
     (cond [(empty? b1) b2]
     	  [(empty? b2) b1]
 		  [else (make-pair b1 b2)]))
 ;; how many times does n occur in bunch b?
 (define (bunch-count-num b n)
     (cond
         [(empty? b) 0]
     	[(number? b) (cond [(= b n) 1]
     					   [else 0])]
 		[else (+ (bunch-count-num (pair-a b) n)
                  (bunch-count-num (pair-b b))]))
 (define (bunch-remove-num b n)
     (cond
         [(empty? b) n]
     	[(number? b) (cond [(= b n) empty]
     					   [else b])]
 		[else
 			(make-pair
              (bunch-remove-num (pair-a b) n)
              (bunch-remove-num (pair-b b) n))]))
 ```

 ``` lisp
 ;; bunch-set - bunch of numbers
 ;;   no numbers appears more than once
 (define (bunchset-add-num b n)
     (cond
         [(zero? (bunch-count-num b n))
         				(bunch-add-num b n)]
     	[true b]))
 (define (bunchset-union b1 b2))
 ```

 ---

## Lec...

 ``` lisp
 (define (max-lt t v);; max element of t less than v
     (cond
         [(empty? t) 'info]
     	[(< (node-e t) v) (max (node-e t)
                                (max-lt (node-r t) v))]
 		[true (max-lt (node-l t) v)]))

 ```

### total order

 a relation $\leq$ over a set S with these properties:

 -for any $a,b\in S$ 	 $a\leq b$ or $b\leq a$
 ​				$a\leq b \cap b\leq a \implies a\equiv b$

 -for any $a,b,c$          $a\leq b \cap  b\leq c \implies a \leq c$ (transitive property)

## Lec

 ``` lisp
 (define (build-list1 n)
     (if (zero? n) empty (snoc (build-list1 (sub1 n)) n)))
 (define (snoc l e)
     (if (empty? l) '(e) (cons (car l) (snoc (cdr l) e))))
 (define (build2 n)
     (if (zero? n) '() (append (build2 (sub1 n)) (list n))))
 ```

## types

 (Aka, Data types)

### Concrete Data Types

 * Particular data structure to represent set of values
 * Implementations of the operations on data structure

### Abstract Data Type

 * abstract set of values (no ... representation specified)
 * set of operations
 * ADT is defined entirely by the operations

 ``` lisp
 #lang racket
 (provide tree-op empty-tree ...) ; ADT operators
 (define empty-tree (make-tree empty))
 -----
 (define-struct tree) ; concrete data type
 (define-struct node l r)
 (define (tree-op t)
     (inner-tree-op (tree-t y)))
 (define (inner-tree-op t) ...)
 ;; implementation only
 ```

 information hiding



 ```lisp
 (define (f x) x)
 (procedure? f) ; true
 ```

 ```lisp
 (define (ffib n)
     (fhelp 0 1 n))
 (define (fhelp this next n)
     (cond
         [(zero? n) this]
     	[else (fhelp next (+ this next) (sub1 n))]))

 (define (rfib-list n)
     (cond
         [(zero? n) '(1 0)]
 		[else
 			(let
              ((x (rfib-list (sub1 n))))
              (cons (+ (car x) (cadr x)) x))]))

 (define (fib-list n) (reverse (cddr (rfib-list n))))

 (define (ffib-list n)
 	(reverse (cddr
           (foldl
           (lambda (x y) (cons (+ (car y) (cadr y)) y))
            (list 1 0)
            (build-list n add1)))))


 ```

 ``` lisp
 #lang racket
 (define-struct fib (this next))
 (define fibs (make-fib 0 1))
 (define (fib-car f) (fib-this f))
 (define (fib-cdr f)
     (make-fib (fib-next f) (+ (fib-this f) (fib-next f))))

 (fib-car (foldl (lambda (x y) (fib-cdr y))
                 fibs
                 (build-list 1000 identity)))

 ```

 ``` lisp
 (define-struct fibstream (first rest))
 (define (make-fs f)
     (make-fibstream f
                     (lambda ()
                             (make-fs (make-fib (fib-next f) (+ (fib-this f) (fib-next f)))))))
 (define fs (make-fs (fib 0 1)))
 (define (fs-car x) (fib-this (fibstream-first x)))
 (define (fs-cdr x) ((fibstream-rest x)))

 ; (fs-car (foldl (lambda (x y) (fs-cdr y)) fs (build-list 1000 identity)))
 ; (fs-car (fs-cdr fs))
 ```

 ``` lisp
 (define-struct stream (first rest))
 (define (make-s f)
     (make-stream (lambda () (fib-this f))
                  (lambda () (make-s (make-fib (fib-next f (+ (fib-this f))))))))

 (define s (make-s (fib 0 1)))
 (define (s-car x) ((stream)))
 ```

 ```lisp
 (define (make-sq f)
     (make-stream (lambda () (sqr f)) (lambda() (make-sq (add2 f)))))
 (define sq (make-sq 1))
 (s-car (s-cdr (s-cdr (s-cdr sq))))
 ```

 ``` lisp
 (define (make-gen f extract continue)
     (make-stream
      (lambda () (extract f))
      (lambda () (make-gen (continue f) extract continue))))
 (define t (make-gen (make-fib 0 1)
                     (lambda (x) (fib-this x))
                     (lambda (x) (make-fib (fib-next x)
                                           ))))

 (define (s-take s n)
     (cond
         [(0? n) empty]
     	[true (cons (s-car s) (s-take (s-cdr s) (sub1 n)))]))
 (define (s-map f s)
     (make-gen
      s
      (lambda (x) (f (s-car) x))
      (lambda (x) (s-cdr x))))


 ```

 ```lisp
 (define t (lambda (x y) x))
 (define f (lambda (x y) y))
 (define ten (lambda () 10))
 (define twenty (lambda () 20))
 (define bad (lambda() ((lambda(x) (x x))
                        (lambda (x) ((x x))))))

 (define (myif tst tru fal)
     (tst tru fal))
 (define (mycons a b)
     (lambda (x) (x a b)))
 (define (mycar p) (p t))
 (define (mycdr p) (p f))
 (define myempty (lambda (x) t))
 (define (myempty? p) (p (lambda (x y) f)))

 (myempty? myempty)
 (myempty? (mycons ten twenty))
 ```
