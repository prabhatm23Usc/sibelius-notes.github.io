---
layout: post
title: CS 241E
term: 1189
subject: cs
feature_image: "https://picsum.photos/2560/600?image=875"
feature_text: |
    <h2 style="color:white;"> Scala Compiler </h2>
---

 > I was auditing this course during this term.

At the beginning, I was expecting that auditing this course would help me on [cs 241](/2019/05/01/CS241/) next term. Similarly with [cs 145](../CS145/), I can't learn anything without doing the assignments...

The course's structure is changing all over the years since it was invented, but the main idea is the same.

The most pleasing thing is all tests on marmoset is public... but takes some time to pass them all...

This is more abstract than cs 241, but it's not that hard if you get all assignments.

Below are my partial notes, and here are [fall 2016 notes](http://davepagurek.github.io/SE-Notes/cs241e/CS241e.html) from Dave Pagurek. Note that you should come to lectures since notes vary from term to term. Also his [se 380](http://davepagurek.github.io/SE-Notes/se380/index.html) is great.

---
## Info

Prof: Lhotak, Ondrej



Programs/data: Racket ………….

/\

| 					|

|					|

| abstractions               | compiler cs444

|					|

|					\/

Computers: bits      Machine language



types

objects

Functions/ procedures

Control structures

arithmetic expressions

variables



end of intro

---



## Lec1

1000011 - conventions！

​	67 natural num

​	c char.

​	-3 signed int.

**Binary comparison**: 1000011 => 67

**Encoding in binary**: 42 = 32+8+2



\\(\infty,\mathbb{Z}\\)

n bits -> 2^n combinations

Which integers?



\\(2^0 + \dots + 2^{n-1} = 2^n - 1\\)

0... 2^n - 1 (unsigned integers)

2's complement signed integers


Machine implements + - * modulo $2^n$

**Thm:**


\\[
\begin{array}{}
a \equiv a^\prime \ \text{mod} \ n
\\
b\equiv b^\prime \ \text{mod} \ n
\end{array}
 \Bigg\}
\implies a + b \equiv a^\prime + b^\prime \ \text{mod} \ n
\\]

/, <, > need separate implementations



## Lec2

State = \\(\{0 ,\ 1\}^{2^{27}+32*34}\\)

Control unit implements a function step: State \\(\rightarrow\\) State

Def: \\(s_i = \text{step}(s_{i-1}) \quad s_0,s_1, \cdots\\)

Need general purpose step function

```scala
step(state) = {
    instruction = state.mem(state.reg(PC)) // fetching instruction
    state2 = state.setReg(PC, state.reg(PC)+4) // increment PC program counter
    instruction match { //decode/execute instruction
        ...
    }
}
```

Slogan: CODE IS DATA




## Lec 03

**DEF** an opcode is a word that represents a machine language instruction (ADD, JR) ***first instruction***

**DEF** assembly language is a language for writing manchine language programs using opcodes and labels.

**DEF** an assembler is a program that translates assembly language to machine language.

**DEF** a label is an abstraction of a memory address.

---

Eg. Find absolute value of $1

```scala
SLT(2,1,0)
BEQ(2,0,?)
SUB(1,0,1)
JR(31)
```

```scala
SLT(2,1,0)
beq(2,0,label)
SUB(1,0,1)
Define(label)
JR(31)
```

---

A1: program = seq[Word]

A2: program =seq[Code]

**DEF** a symbol table is a map from names(labels) to their meanings (memory address)

How to eleminate labels?

 -Need 2 passes:

​	pass1: determine address of each label (build symbol table)

​	pass2 :convert uses of each label to address or offset (use symbol table)



## LEC04

```scala
0	lis $1
4	Use(p)
8	jalr $1
```

$\downarrow$ asm

object files

```
e | a		lis $1
--+---		0
  |
Use(p)@4	jalr $1
```



``` scala
  Define(p)
0 lis $1
4 Use(e)
8 jr $1
  Define(2)
  jr $31
```

\\(\downarrow\\) asm (assemble)

object file $\downarrow$

```
label | addr
------+-------			|lis $1  |
p     |_0_ 12			|  12    |
e	  |_12_ 24			|  jr $1 |
Use(e)@_4_16			|  jr $31|
					  -------- machine language

_number_ means crossed out
```



Two things above link \\(\downarrow\\)

```
0	lis $1
4	_0_ 12
8	jalr $1
12	lsis $1
16	_12_ 24  
20	jr $1
24	jr $31
```







Relocation and Linking

---

Def: An object file contains machine language with extra metadata that records where labels are defined (symbol table) and used.

Def: Linking is the process of combining object files into one program/library. It involves:

* relocation

- resolving (connecting) labels from different object files.

Def: Relocation is the process of adjusting addresses in machine language, so it can be loaded at a different address.



**Variables**

---

Def: a variable is an abstraction of a storage location that can hold a value.

Def: The extent of a variable instance is the time intervalin which the variable can be accessed.

```
variable kind    | extent		    | implementation	-----------------+------------------|----------------
global		     | entire execution | fixed location
-----------------+------------------+-----------------
procedure - local| one execution of | stack
				 | the procedure(LIFO)|
-----------------+------------------+-------------------
field of an 	   | object creation| heap
object/record/cons | to last use    |
```

e.g.

``` scala
def f(x <= lnt): lnt = if (x<2) 1 else x*f(x-1)
fact(3)=3*f(2)=3*2*f(1)=3*2*1
```

```
			 f(1)--x=1--|___
		f(2)|x=2___________| __
f(3)_________x=3_______________|
			time ->   extent
```

```
| Program |
|_________|
|		  |
|		  |
|		  |
|		  |
-----------
/\
|push	  |
|	   pop|
		  \/
-----------
|  stack  |
|		  |
|		  |
```

Implement Stack

-designate register to hold address of top of stack "stack pointer" \$30

-push - subtract 4

-pop - add 4

e.g. read c

LW(Reg(1), 8, Reg(30))

## Lec 5

Symbol table

```
variable | offset
---------+--------		compile time
         |
```

Def: a frame pointer is a copy of the stack pointer made at beginning of procedure call that does not change during call. This enables us to change/use stack pointer.

MIPS convention: \$29

In assignments, all data in memory organized in chunks.

```
0 | size    |
--+---------|
4 | A11		|
--+---------|_
a->8 |		| |
b->12|		| |=>data
c->16|		|_|
```

Chunk is
-block of consecutive memory locations.
-Offsets indexed by variables.



e.g. `a*b+c*d`

```
	+
   / \
  *   *
 /\   /\
a b  c  d
```

Technique 1 (stack)

* general :)
* inefficient :(
* hard to optimize code :(

```scala
def evaluate(e1 op e2)
// generate code that evaluate e1 op e2
// and put result in $3
= block(
		evaluate(e1)
		push $3
		evaluate(e2)
		pop $4
		$3 = $4 op $3
	)
```

```
t1 = a*b
t2 = c*d
t3 = t1+t2
```

Technique 2 (variables)

* machine language does not support variables :(
* Many variable :(
* :) this code is "easy" to impove

```scala
def evaluate(e1 op e2) : (Code, Variable) = {
// generate code that evaluate e1 op e2
// and put result in a variable
(c1,v1)=evaluate(e1)
(c2,v2)=evaluate(e2)
    v3=new Variable("temp")
	code = c1++c2 :+(v3= v1 op v2)
    (code,v3)
}
```

### Register allocation
