---
title: CS 350 - Operating Systems
layout: markdown
---

<div class="content">

<h1>CS 350 - Operating Systems</h1>

<div class="md-toc content">
    <p class="md-toc-content">
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#intro">Intro</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#threads">Threads</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#review-from-whatever-course">Review from whatever course</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#concurrent-program-execution">Concurrent Program Execution</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#context-switch">Context Switch</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#thread-states">Thread States</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#preemptive-scheduling">Preemptive Scheduling</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#synchronization">Synchronization</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#other-sources-of-race-conditions">Other sources of Race conditions</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#deadlocks">Deadlocks</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#process">Process</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#fork">fork</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#_exit">_exit</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#waitpid">waitpid</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#execv">execv</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#system-calls">System Calls</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#kernel-privilege">Kernel Privilege</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#user-and-kernel-stacks">User and Kernel Stacks</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#exception-handling">Exception Handling</a>
    </span>
    <span class="md-toc-item md-toc-h3">
        <a class="md-toc-inner" href="#mips_trap">mips_trap</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#multiprocessing">Multiprocessing</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#stack-diagrams">Stack Diagrams</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#inter-process-communication-(ipc)">Inter-Process Communication (IPC)</a>
    </span>
    </p>
</div>


<!--start--><p>miscellaneous notes... Also, check my <a href="../cs350help/">help page</a></p>
<p>Lesley&#39;s lectures recording starts from lec 7.</p>
<h1 id="intro"><a class="header-link" href="#intro"></a>Intro</h1>
<p>OS:</p>
<ul class="list">
<li>manages resource</li>
<li>creates execution environments.</li>
</ul>
<p>Three views:</p>
<ol class="list">
<li>Application view: provide services<ul class="list">
<li>part cop: provides protection from program errors. part facilitator: abstract interface to underlying system</li>
<li>What services?<ul class="list">
<li>resources</li>
<li>interfaces</li>
<li>isolates running programs</li>
</ul>
</li>
</ul>
</li>
<li>System view: solve problems<ul class="list">
<li>manages the hardware resources</li>
<li>allocates resources</li>
<li>controls the access to or sharing of resources among programs.</li>
</ul>
</li>
<li>Implementation view: how is it built?<ul class="list">
<li><strong>concurrent</strong>: multi progs or seqs of instrs <em>running, or appearing to run, at the same time</em>.</li>
<li><strong>real-time</strong>: must respond to an event in a specific amount of time.</li>
</ul>
</li>
</ol>
<p><strong>kernel</strong>: The operating system kernel is the part of the operating system that responds to system calls, interrupts and exceptions.</p>
<p><strong>operation system</strong>: The operating system as a whole includes the kernel, and may include other related programs that provide servicesfor applications.  This may include things like:</p>
<ul class="list">
<li>utility programs (e.g. disk defragmenter, task manager)</li>
<li>command interpreters (e.g. cmd.exe in Windows, bash in Linux)</li>
<li>programming libraries (e.g. POSIX threads in Linux)</li>
</ul>
<p><strong>monolithic kernel</strong>: the entire operating system (which includes the device drivers, file system, and the application IPC) is working in kernel space. &quot;everything and the kitchen sink&quot; is a part of the
kernel. This includes device drivers, file system, virtual memory, etc.</p>
<p><strong>microkernel</strong>: only absolutely necessary components are a part of the
kernel. All other elements are user programs.</p>
<p><strong>real-time OS</strong>: an OS with stringent event response times,
guarantees, and preemptive scheduling.</p>
<p>The <strong>execution environment</strong> provided by the OS includes a variety of
<strong>abstract entities</strong> that can be manipulated by a running program.</p>
<h1 id="threads"><a class="header-link" href="#threads"></a>Threads</h1>
<p>seq of instructions.</p>
<p>a single program can have</p>
<ul class="list">
<li>diff threads responsible for different roles</li>
<li>multi threads --- same roles</li>
</ul>
<p>Reasons we use threads:</p>
<ul class="list">
<li>Efficient Use of Resource</li>
<li>parallelism</li>
<li>responsiveness</li>
<li>priority</li>
<li>modularization</li>
</ul>
<p>A thread <strong>blocks</strong>, when it ceases execution for a period of time, or, until some condition has been met (e.g.  a website respondsor a user moves the mouse). CPU is idle.</p>
<p>Key ideas:</p>
<ul class="list">
<li>A thread can create new threads using <code>thread_fork</code></li>
<li>new threads start execution in a function specified as a param to <code>thread_fork</code></li>
<li>original (called <code>thread_fork</code>) and new thread proceed concurrently</li>
<li>All threads share access to program&#39;s global vars and heap</li>
<li>each thread has its own stack (private to that thread)</li>
</ul>
<p>In the OS, a thread is represented as a struct or object</p>
<p>An example of using <code>thread_fork</code> to create a new thread that is running the function <code>vehicle_sumulation</code>.</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; NumThreads; i++) {
    error = thread_fork(<span class="hljs-string">"vehicle simulation thread"</span>, <span class="hljs-literal">NULL</span>,
        vehicle_simulation, <span class="hljs-literal">NULL</span>, i);
    <span class="hljs-keyword">if</span> (error) {
        panic(<span class="hljs-string">"traffic sim: thread_fork failed: %s"</span>,
            strerror(error));
    }
}</code></pre><p><strong>Interface</strong></p>
<ul class="list">
<li>create a new thread:<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">thread_fork</span><span class="hljs-params">(
  <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *name, <span class="hljs-comment">// name of new thread</span>
  <span class="hljs-keyword">struct</span> proc *proc, <span class="hljs-comment">// thread’s process</span>
  <span class="hljs-keyword">void</span> (*func)</span> <span class="hljs-comment">// new thread’s function</span>
      <span class="hljs-params">(<span class="hljs-keyword">void</span> *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>)</span>,
  <span class="hljs-keyword">void</span> *data1, <span class="hljs-comment">// function’s first param</span>
  <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> data2 <span class="hljs-comment">// function’s second param</span>
)</span>;</code></pre></li>
<li>terminate the calling thread: <code>void thread_exit(void);</code></li>
<li>volutarily yield execution: <code>void thread_yield(void);</code></li>
</ul>
<h2 id="review-from-whatever-course"><a class="header-link" href="#review-from-whatever-course"></a>Review from whatever course</h2>
<p><strong>Review: Sequential Program Execution</strong></p>
<ul class="list">
<li>fetch instr (from code segment) that the Program counter points to</li>
<li>decode and execute the instr and</li>
<li>increment the PC</li>
</ul>
<blockquote>
<p>Note: In CS241 we names the MIPS registers $0, $1,
$2, etc. In CS350 we referred to them by their default function,
e.g. v0, a0, t0.</p>
</blockquote>
<p><code>t0-t7</code>: temps (caller-save). if the calling subroutine has a value in one of
these registers that it wants preserved, it should store the value
on the stack before calling any subroutines and restore it
afterwards.</p>
<p><code>s0-s7</code>: saved (callee-save). if the called subroutine uses one of these
registers is must first store its current value on the stack and
restore it before exiting</p>
<p>This strategy tries to <em>miminize situations where the callee is saving values that the caller is not using</em>.</p>
<p><strong>Review: The Stack</strong>: grows downward in slides.</p>
<p>Conceptually, each thread executes sequentially using its private register contents and stack.</p>
<h2 id="concurrent-program-execution"><a class="header-link" href="#concurrent-program-execution"></a>Concurrent Program Execution</h2>
<p><strong>Key Question</strong>: What is shared between threads?</p>
<ul class="list">
<li>They are both executing (perhaps at the same time on different cores) the same program.</li>
<li>Both threads share the same code, read-only data, global variables and heap.</li>
<li>Each thread has its own stack and PC.</li>
</ul>
<p>Three options:  </p>
<ul class="list">
<li>Hardware support (P processors, C cores, M multithreading per core)</li>
<li>Timesharing: Multiple threads tak turns on the same hardware; rapidly switching.</li>
<li>Hardware support + Timesharing</li>
</ul>
<p>When <strong>timesharing</strong>, the switch from one thread to another is called a <strong>context switch</strong>.</p>
<h2 id="context-switch"><a class="header-link" href="#context-switch"></a>Context Switch</h2>
<ul class="list">
<li>decide which thread will run next (scheduling)</li>
<li>save register contents of current thread</li>
<li>load register contents of next thread</li>
</ul>
<p>Thread context (register values) must be saved/restored
carefully, since thread execution continuously changes the
context.</p>
<p>The threads share the CPU, giving the user the illusion of multiple
programs running at the same time.</p>
<p><strong>On MIPS</strong></p>
<pre class="hljs"><code><span class="hljs-keyword">switchframe_switch:
</span>    <span class="hljs-comment">/* a0: address of switchframe pointer of old thread. */</span>
    <span class="hljs-comment">/* a1: address of switchframe pointer of new thread. */</span>

    <span class="hljs-comment">/* Allocate stack space for saving 10 registers. 10*4 = 40 */</span>
    <span class="hljs-keyword">addi </span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, -<span class="hljs-number">40</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">ra</span>, <span class="hljs-number">36</span>(<span class="hljs-built_in">sp</span>)   <span class="hljs-comment">/* Save the registers */</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">gp</span>, <span class="hljs-number">32</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s8</span>, <span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)   <span class="hljs-comment">/* a.k.a. frame pointer */</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s6</span>, <span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s5</span>, <span class="hljs-number">20</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s4</span>, <span class="hljs-number">16</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s3</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s2</span>, <span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s1</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)

    <span class="hljs-comment">/* Store the old stack pointer in the old thread */</span>
    <span class="hljs-keyword">sw </span><span class="hljs-built_in">sp</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">a0</span>)

    <span class="hljs-comment">/* Get the new stack pointer from the new thread */</span>
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">sp</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">a1</span>)
    <span class="hljs-keyword">nop </span>            <span class="hljs-comment">/* delay slot for load */</span>

    <span class="hljs-comment">/* Now, restore the registers */</span>
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s0</span>, <span class="hljs-number">0</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s1</span>, <span class="hljs-number">4</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s2</span>, <span class="hljs-number">8</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s3</span>, <span class="hljs-number">12</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s4</span>, <span class="hljs-number">16</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s5</span>, <span class="hljs-number">20</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s6</span>, <span class="hljs-number">24</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">s8</span>, <span class="hljs-number">28</span>(<span class="hljs-built_in">sp</span>)   <span class="hljs-comment">/* a.k.a. frame pointer */</span>
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">gp</span>, <span class="hljs-number">32</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">lw </span><span class="hljs-built_in">ra</span>, <span class="hljs-number">36</span>(<span class="hljs-built_in">sp</span>)
    <span class="hljs-keyword">nop </span>            <span class="hljs-comment">/* delay slot for load */</span>

    <span class="hljs-comment">/* and return. */</span>
    <span class="hljs-keyword">j </span><span class="hljs-built_in">ra</span>
    <span class="hljs-keyword">addi </span><span class="hljs-built_in">sp</span>, <span class="hljs-built_in">sp</span>, <span class="hljs-number">40</span> <span class="hljs-comment">/* in delay slot */</span>
    <span class="hljs-meta">.end</span> <span class="hljs-keyword">switchframe_switch</span></code></pre><p>C function <code>thread_switch</code> calls the assembly language subroutine <code>switchframe_switch</code>.</p>
<p><code>thread_switch</code> caller: save/restore the <em>caller-save</em> regs, including return address (ra)</p>
<p><code>switchframe_switch</code> callee: save/restore <em>callee-save</em> regs. In OS/161 the frame pointer is callee saved.</p>
<p><code>switchframe_switch</code>, saves callee-save registers to the old
thread’s stack; it restores the callee-save registers from the new
thread’s stack.</p>
<p>MIPS R3000 is pipelined; delay-slots are used to protect against <em>load-use hazards</em>, <em>control hazards</em>.</p>
<p><em>What Causes Context Switches?</em></p>
<ol class="list">
<li><code>thread_yield</code>: voluntarily allows other threads to run</li>
<li><code>thread_exit</code>: terminated</li>
<li>blocks, via a call to <code>wchan_sleep</code>: it is waiting for some resource (such as network access) or for some event to happen</li>
<li>is preempted: it involuntarily stops running (because the thread scheduler stopped it)</li>
</ol>
<h2 id="thread-states"><a class="header-link" href="#thread-states"></a>Thread States</h2>
<p class="img-container"><img src="/pics/thread_state.png" width=100%></p>
<p>Running: current executing. Ready: ready to execute. Blocked: waiting for sth, so not ready to execute.</p>
<p><code>thread_yield</code> (C function) yield CPU. <code>thread_yield</code> calls (C function) <code>thread_switch</code> (high level context switch). <code>thread_switch</code> chooses a new thread then calls (assembly subroutine) <code>switchframe_switch</code> (low level).</p>
<p><strong>Scheduling quantum</strong> imposes a limit on processor time: upper bound on how long a thread can run before it must yield the CPU.</p>
<p>An <strong>interrupt</strong> is an event that occurs during the execution of a program.</p>
<ul class="list">
<li>caused by system devices (hardware): timer, disk controller, network interface card.</li>
<li>when interrupt occurs,  the hardware automatically transfers control to a fixed location in memory (specified by the designer of the CPU).</li>
<li>At that location, the the thread library must place a procedure called an <strong>interrupt handler</strong>.</li>
<li>the interrupt handler normally:<ul class="list">
<li>creates a trap frame to record the thread context at the time of the interrupt,</li>
<li>determines which device caused the interrupt and performs device-specific processing,</li>
<li>restores the saved thread context from the trap frame and resumes execution of the thread.</li>
</ul>
</li>
</ul>
<p><strong>Thread context</strong> is all the information (i.e. register values) needed to resume executing a thread after it has been suspended.
and it&#39;s stored in a switchframe.</p>
<p>When a thread is interrupted all the register values are stored in a <strong>trap frame</strong>.</p>
<h2 id="preemptive-scheduling"><a class="header-link" href="#preemptive-scheduling"></a>Preemptive Scheduling</h2>
<ul class="list">
<li>Threads may block or yield before their quantum has expired.</li>
<li>If a thread has run too long, the timer interrupt handler preempts the thread by calling <code>thread_yield</code>.</li>
<li>The preempted thread changes state from running to ready, and it is placed on the <strong>ready queue</strong>.</li>
<li>OS161 threads use preemptive round-robin scheduling:<ul class="list">
<li>scheduler maintains a queue of threads, often called the ready queue.</li>
<li>On a context switch, the running thread is moved to the end of the ready queue, and the first thread on the queue is allowed to run.</li>
<li>Newly created threads are placed at the end of the ready queue.</li>
</ul>
</li>
<li>Threads can be migrated to other processors or interrupted by device so the order they run is nondeterministic.</li>
</ul>
<p>Then see two examples in slides (one and two threads): involuntary/voluntary context switch.</p>
<div class='ex'>
<div class="ex-title">
Review Questions
</div>

<div class='ex-content'>
<p>Every thread has its own stack.</p>
<p>Threads can only run in parallel (execute instructions simultaneously) if there is hardware support (via multiple CPUs, cores, etc.).</p>
<p>Which of the following are NOT reasons to use threads?</p>
<ul class="list">
    <li>resource utilization</li>
    <li><em>isolation from errors</em></li>
    <li>computation time</li>
    <li>organization</li>
</ul>
</div>
</div>



<div class='ex'>
    <div class="ex-title">In-Class Problems: twothreads</div>
    <div class='ex-content'>
    Suppose that there are two threads in a system that uses preemptive round-robin scheduling with a
    scheduling quantum of Q milliseconds. The system has a single processor. Each thread runs a function
    which behaves as follows

<pre>
<code>
for i from 1 to N do
    compute for C milliseconds
    sleep for S milliseconds
end
</code>
</pre>

    At the end of its for loop, a thread is finished and it exits. During the “compute” part of each iteration,
    a thread is runnable (running or ready to run). During the “sleep” part of each of its iterations, a thread is
    blocked. For both parts of this question assume that C &lt; Q and C &lt; S.
<br><br>
    <strong>a.</strong> First, assume that C &lt; S and C &lt; Q. Suppose that both of the threads are created at time t = 0. At what time will both of the threads be finished? Answer in terms of Q, N, C, and S, as necessary.
<br><br>
    <strong>Soln</strong>: Let <code>C -&gt; XXX, S -&gt; YYYY.</code>

<pre>
<code>
T_0     XXX | YYYYXXX | ... |
T_1         | XXXYYYY | ... | YYYY
</code>
</pre>

    Thus the answer is \(N(C+S)+C\)
<br><br>
    <strong>b.</strong> Answer the same question, but this time assume that S &lt; C &lt; Q.
<br><br>
    <strong>Soln</strong>: Let <code>C -&gt; XXXX, S -&gt; YYYY.</code>

<pre>
<code>
T_0     XXXX | YYYZXXXX | ... | ... YYYZ |
T_1          | XXXXYYYZ | ... | ... XXXX | YYY
</code>
</pre>

    Thus the answer is \(2NC + S\)
    </div>
</div>




<h1 id="synchronization"><a class="header-link" href="#synchronization"></a>Synchronization</h1>
<blockquote>
<p>Lesley&#39;s recordings start here.</p>
</blockquote>
<p>We left last class: semaphores and CV. Different primitives for concurrency problem.</p>
<ul class="list">
<li>Semaphore:<ul class="list">
<li>any number of resources. <code>P</code> acquire, <code>V</code> release. Use as a lock. Keep in mind it&#39;s not lock. There&#39;s no built-in protection for it, no track of ownership: someone else tries to release <strong>binary</strong> semaphore on me, they can, and we have race condition.</li>
<li><strong>counting</strong>: keep counting # of resources</li>
<li><strong>barrier</strong>: force one thread to wait for others to complete before we proceed. Not separate implementation.</li>
<li>keep in mind do not touch the counter directly. It&#39;s a shared resource.</li>
</ul>
</li>
<li>CV: you are inside critical section. You really need condition to be true to proceed. But the lock you own it the lock you are using to protect the shared variable that has unique value. CV lets us do simultaneously safely let go of the lock and fall asleep so that another thread can modify the condition and wake us back up.<br>
Most of the type we are using: when we are woken back up, we need to recheck the condition.</li>
</ul>
<h2 id="other-sources-of-race-conditions"><a class="header-link" href="#other-sources-of-race-conditions"></a>Other sources of Race conditions</h2>
<p>The previous RC is because of the code you wrote.</p>
<p><strong>memory models</strong> describe how thread access to memory in shared regions behave. a memory model tells the compiler and CPU which optimizations can be performed</p>
<p><strong>compiler</strong>: it does optimization. Reduce the # of assembly instrs: load and stores.</p>
<pre class="hljs"><code><span class="hljs-keyword">int</span> sharedTotal = <span class="hljs-number">0</span>;
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FuncA</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//... code that uses sharedTotal ...</span>
}
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FuncB</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">//... code that uses sharedTotal ...</span>
}</code></pre><p>Instead of go to RAM, much more efficient to keep it in register: register allocation. Here&#39;s the problem: It doesn&#39;t know if A and B run at the same time. If one put in <code>$3</code> one in <code>$8</code>. Big race condtion. There are also others optimization.</p>
<p>Always load/store var from RAM, not reordering: <code>volatile</code>. Disable compiler optimizations, but not solve race conditions in your codes.</p>
<p><strong>CPU</strong>: fetch the program counter, decode it, execute it and move on. But it&#39;s more complex: pipeline, branch prediction, reorder instrs... It also has memory model and so that you can notify the CPU: multi-threaded code is going on here. Barrier or fence instrs to entry gate: CPU stops rearranging. And until end gate, turn on opt back on. Don&#39;t need to worry in OS161.</p>
<div class='ex'>
    <div class="ex-title">In class problem: semaphore to CV</div>
    <div class='ex-content'>
<table>
    <thead>
        <tr>
            <th>Global Vars</th>
            <th>Initialization</th>
            <th>Function <code>func1</code></th>
            <th>Function <code>func2</code></th>
        </tr>
    </thead>
<tbody>
<tr>
<td>
<pre>
struct semaphore *sa;
struct semaphore *sb;
struct semaphore *sc;
</pre>
</td>
<td>
<pre>
sa = sem_create(&quot;A&quot;, 1);
sb = sem_create(&quot;B&quot;, 1);
sc = sem_create(&quot;C&quot;, 0);
</pre>
</td>
<td>
<pre>
void func1() {
    P(sa);
    funcA();
    V(sa);
    P(sc);
}
</pre>
</td>
<td>
<pre>
void func2() {
    P(sb);
    funcB();
    V(sb);
    P(sc);
}
</pre>
</td>
</tr>
</tbody>
</table>

Re-implement <code>func1</code> and <code>func2</code> using lock and cv.
<br><br>
<strong>Solution</strong>: func1 is consumer, func2 is producer.
<br>
<pre>
<code>
lock A, B, C;
CV cv;
count = 0;

func1 {
    lock_acq(A)
        funcA()
    lock_rel(A)

    lock_acq(C)
        count--
        if (count &lt; 0) cv_wait(cv, C)
    lock_rel(C)
}

func2 {
    lock_acq(B)
        funcB()
    lock_rel(B)

    lock_acq(C)
        if (count &lt; 0) cv_signal(cv, C)
        count++
    lock_rel(C)
}
</code>
</pre>
    </div>
</div>




<h2 id="deadlocks"><a class="header-link" href="#deadlocks"></a>Deadlocks</h2>
<pre class="hljs"><code>lock lockA, lockB;

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FuncA</span><span class="hljs-params">()</span> </span>{
    lock_acquire(lockA)
    lock_acquire(lockB)
    ...
    lock_release(lockA)
    lock_release(lockB)
}

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">FuncB</span><span class="hljs-params">()</span> </span>{
    lock_acquire(lockB)
    lock_acquire(lockA)
    ...
    lock_release(lockB)
    lock_release(lockA)
}</code></pre><ul class="list">
<li>Thread 1 executes <code>lock_acquire(lockA)</code></li>
<li>Thread 2 executes <code>lock_acquire(lockB)</code></li>
<li>Thread 1 executes <code>lock_acquire(lockB)</code></li>
<li>Thread 2 executes <code>lock_acquire(lockA)</code></li>
</ul>
<p>Deadlock only shows up under certain order of thread execution. It is very difficult to detect: between problematic wait and wait on purpose.</p>
<p>Generally, it happens when multiple threads, each acquire multiple resources.</p>
<ol class="list">
<li>don&#39;t try to aquire a lock if you have already owned.</li>
<li>Two strategies</li>
</ol>
<p><strong>No hold and wait</strong>: while you own the resources, no wait (no block, no spin).
<br> Being able to aquire all resources at once. We need special implementation of lock to support.</p>
<p>If you can&#39;t acq a lock, you can&#39;t fall asleep. Special implementation of acq.</p>
<pre class="hljs"><code><span class="hljs-comment">// true if you get the lock</span>
<span class="hljs-comment">// false if cannot, but do not go to sleep.</span>
<span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">try_acq</span><span class="hljs-params">(lk)</span> </span>{
    acq(lk-&gt;spin)
        <span class="hljs-keyword">if</span> (lk-&gt;held) {
            release(lk-&gt;spin)
            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
        }
        lk-&gt;held =  <span class="hljs-literal">true</span>
        lk-&gt;owner = me
    release(lk-&gt;spin)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}</code></pre><p>Solution to previous deadlock:</p>
<pre class="hljs"><code>acq(A) <span class="hljs-comment">// I own nothing and safely acquire</span>

<span class="hljs-keyword">while</span> (!try_acq(B)) {
    release(A)
    <span class="hljs-comment">// if you want to improve the performance, put yield here</span>
    acq(A)
}</code></pre><p>But it&#39;s nasty if we want acq lots of things, also it&#39;s spinning.</p>
<p><strong>Resource ordering</strong>: assign every single resource a single number. Acquire them only in strictly increasing order. There&#39;s problem if different programmers have different rules.</p>
<div class='ex'>
<div class="ex-title">
In class problem: queuexfer
</div>

<div class='ex-content'>
Suppose that a threaded program has N queues of items. The program needs to support an operation called <code>Transfer(i,j)</code>. Each call to <code>Transfer</code> will transfer a single item from the i-th queue to the jth queue,
unless there is nothing in the i-th queue, in which case the call will not affect the queues.
<br>The program will have multiple concurrent threads, each of which may call <code>Transfer</code> zero or more times.
<br>How would you use locks to ensure that <code>Transfer</code> operations are atomic? Specifically, how many locks
would you use, what would each lock protect, and when would the locks be acquired and released to ensure
that transfers are atomic?

<br><br>
One way: no hold and wait. Downside: cannot both lock at the same time, busy wait: spin.

<br><br>
Alternate: resource ordering.
<pre>
<code>
Transfer(Q_a, Q_b) {
    // check resource number
    if (a &lt; b) {
        acq(qa)
        acq(qb)
    } else {
        acq(qb)
        acq(qa)
    }
}
</code>
</pre>
Downside: you need to sort if you acq all resources \(\Theta(n\log n)\).
</div>
</div>





<h1 id="process"><a class="header-link" href="#process"></a>Process</h1>
<p>is an is an environment in which an application program runs.</p>
<p>includes virtualized resources that its program can use: one (or more) threads</p>
<p>each program’s process <em>isolates</em> it from other programs in other processes</p>
<h2 id="fork"><a class="header-link" href="#fork"></a>fork</h2>
<p>creates a brand new process (the child) that is a clone of the original (the parent)</p>
<ul class="list">
<li>new process structure</li>
<li>new address space</li>
<li>new thread array</li>
<li>new PID
clone</li>
<li>content of address space</li>
</ul>
<h2 id="_exit"><a class="header-link" href="#_exit"></a>_exit</h2>
<p>terminate the calling process. Not necessarily disappear: stop executing, address space get cleaned, but if it has parents, that parent is alive. Parents want to figure out why child dies. Leave behind a msg for parent.</p>
<h2 id="waitpid"><a class="header-link" href="#waitpid"></a>waitpid</h2>
<p>offer synchronization between processes. Cause the caller to wait for the PID process to terminate. Restricted to: parent can only wait for their children to die.</p>
<p>Children cannot wait for their parents. If they die, they are old.</p>
<h2 id="execv"><a class="header-link" href="#execv"></a>execv</h2>
<p>Now, the last of the five system calls: execv. It does not create a new process.</p>
<p>It changes the program and a existing process is running. Process structure is same, but the address space has changed.</p>
<p><code>Hello world</code> program, and call <code>execv matlab</code>.</p>
<p>Create a new address space, and load the program into the new address space.</p>
<p>Parent child relationship: If you go home tonight, and dye your hair in green, your parent may not like it. But they cannot change genetically they are your parents. The same is true for processes: you can change the program that you are running but you cannot change parent-child relationship.</p>
<p>Example from slides:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> rc = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">char</span> *args[<span class="hljs-number">4</span>];

    args[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"/testbin/argtest"</span>;
    args[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"first"</span>;
    args[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"second"</span>;
    args[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// null terminator</span>

    rc = execv(<span class="hljs-string">"/testbin/argtest"</span>, args); <span class="hljs-comment">// takes two parameters</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"If you see this execv failed\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"rc = %d errno = %d\n"</span>, rc, errno);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}</code></pre><p>takes two parameters. Many times you need command line arguments. Array of pointers.</p>
<p><code>execv</code> if it succeeds, does not return. Because it successfully created the new address space and new program. We successfully loaded the program into it. The calling program will not exist if <code>execv</code> succeeded. The only time it returns is when it fails. Why would it fail? 30mb ram then run Matlab. It&#39;s possible that there&#39;s no memory left or you call the program wrongly. When you write your <code>execv</code>, you need to test for these error cases and return appropriate error codes. (but cs350 stuff don&#39;t have such tests on these).</p>
<p>You notice that we can&#39;t tell how many arguments there are automatically. So we use null terminator array and you are responsible for counting.</p>
<p>Another example. This time with fork.</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">char</span> *args[<span class="hljs-number">4</span>];
    <span class="hljs-comment">/* set args here */</span>
    rc = fork(); <span class="hljs-comment">/* returns 0 to child, pid to parent */</span>
    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) {
        status = execv(<span class="hljs-string">"/testbin/argtest"</span>,args);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"If you see this execv failed\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"status = %d errno = %d\n"</span>, status, errno);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    } <span class="hljs-keyword">else</span> {
        child_pid = rc;
        parent_code();
        p = waitpid(child_pid,&amp;child_exit,<span class="hljs-number">0</span>);
    }
}</code></pre><p>Now I have two processes. Even though they are separate, but their contents are identical with the exception of value of <code>rc</code>. 0 for child, pid for parent.</p>
<p>If child, <code>execv</code>. Child is running different process. Parent can still wait for child to terminate. Parent child relationship is not impacted by <code>execv</code> which stays forever.</p>
<p>Go home and write thread fork bomb.</p>
<h1 id="system-calls"><a class="header-link" href="#system-calls"></a>System Calls</h1>
<ul class="list">
<li>Process management calls, e.g., fork, are called by user programms. They are also system calls.</li>
<li><strong>System calls</strong> are the interface between user processes and the kernel.</li>
<li>The kernel code runs at the highest privilege level, where any CPU instructions can be executed.</li>
<li>Program in user space cannot execute code or instructions belonging to a higher-level of privilege.</li>
</ul>
<h2 id="kernel-privilege"><a class="header-link" href="#kernel-privilege"></a>Kernel Privilege</h2>
<p>The CPU implements different levels (or rings) of execution
privilege as a security and isolation mechanism. Kernel code at highest level.</p>
<p><strong>Key Question</strong>: Since application programs cannot directly call the
kernel, how does a program make a system call such as <code>fork</code>?</p>
<ol class="list">
<li>Interrupts<ul class="list">
<li>Interrupts are raised by devices (hardware)</li>
<li>An interrupt causes the CPU to transfer control to a fixed location in memory (specified by the designers of the CPU) where an interrupt handler must be located.</li>
<li>Interrupt handlers are part of the kernel.</li>
</ul>
</li>
<li>Exceptions<ul class="list">
<li>conditions that occur during the execution of a program instruction.</li>
<li>The CPU handles exceptions like it handles interrupts:<ul class="list">
<li>Control is transferred to a fixed location, where an exception handler is located.</li>
<li>The processor switches to privileged execution mode.</li>
</ul>
</li>
<li>In OS/161 <em>the same routine is used to handle exceptions and interrupts</em>.</li>
</ul>
</li>
</ol>
<p>When CPU receives interrupt or exception, your program stops executing and exception/interrupt handler is called, part of kernel code. Then CPU switches from unprivileged mode to privileged mode, so now we can execute kernel&#39;s code. Produces the trapframe: storing every single reg value (including special ones) so we can return to the exact point of program execution after we handle.</p>
<p>Extra: <a href="https://meltdownattack.com/">Spectre and Meltdown Papers</a>.</p>
<p><strong>Key Question</strong>: There is only one <code>syscall</code> exception, <code>EX_SYS</code>. So how does the OS distinguish between a <code>fork</code> and <code>getpid</code> system call?</p>
<p><em>system call codes</em></p>
<ul class="list">
<li>The kernel expects the code to be placed in a specified location before executing <code>syscall</code> (for OS/161 on MIPS, reg <code>v0</code>)</li>
<li>the codes and code location are part of the kernal ABI (Application Binary Interface)</li>
</ul>
<p>ABI is not secret because we need user land to know that info and it absolutely tells nothing what&#39;s happening in the kernel -- blackbox.</p>
<p>Example:</p>
<ul class="list">
<li><code>li v0, 0</code> where 0 is the syscall code for <code>fork</code>.</li>
<li>Syscall parameters: load into regs <code>a0</code> to <code>a3</code>. If more, put into stack or heap, and put the address here.</li>
<li>Use <code>syscall</code> to raise exception.</li>
</ul>
<p>Return two values:</p>
<ul class="list">
<li>reg <code>a3</code>: success/fail</li>
<li>reg <code>v0</code>: return value/error code</li>
</ul>
<h2 id="user-and-kernel-stacks"><a class="header-link" href="#user-and-kernel-stacks"></a>User and Kernel Stacks</h2>
<p>Every OS/161 process thread has <strong>two</strong> stacks, although it only uses one at a time.</p>
<p>The only thing that goes into user stack us the user application stack. But before we save the trapframe, we must change the stack pointer from user stack to kernel stack.</p>
<ol class="list">
<li>The User (Application) Stack is used while the thread is executing application code.<ul class="list">
<li>Saw this in <a href="/19-05/CS241/">CS 241</a>.</li>
<li>The kernel creates this stack when it sets up the virtual address space for the process (or thread if the OS supports multi-threaded code).</li>
</ul>
</li>
<li>The Kernel Stack is used while the thread is executing kernel code, i.e. after an exception or interrupt.<ul class="list">
<li>This stack is a kernel structure (i.e. it is located in the kernel’s address space).</li>
<li>It also holds trap frames and switch frames (because it is the kernel that creates trap frames and switch frames)</li>
</ul>
</li>
</ol>
<h2 id="exception-handling"><a class="header-link" href="#exception-handling"></a>Exception Handling</h2>
<ul class="list">
<li>first to run assembly code, <code>common_exception</code><ul class="list">
<li>save stack pointer</li>
<li>switches SP to point to the thread&#39;s kernel stack,</li>
<li>carefully saves app state and address of the instruction,</li>
<li>calls <code>mips_trap</code>, passing a pointer to the trap frame as an arg.</li>
</ul>
</li>
<li>After <code>mips_trap</code> is finished, the <code>common_exception</code> handler will<ul class="list">
<li>restore application&#39;s state</li>
<li>jump back to application instruction that was interrupted and switch back to unprivileged execution mode.</li>
</ul>
</li>
<li>See <code>kern/arch/mips/locore/exception-mips1.S</code> (assembly file)</li>
</ul>
<h3 id="mips_trap"><a class="header-link" href="#mips_trap"></a>mips_trap</h3>
<p>determines what type of exception it is by looking at the exception code.</p>
<p>(there is a separate handler in the kernel for each type of exception.) Based on that exception code, call appropriate handler.</p>
<ul class="list">
<li>interrupt? call <code>mainbus_interrupt</code></li>
<li>address translation exception? <code>vm_fault</code></li>
<li>system call? call <code>syscall</code> (kernel function), passing it the trap
frame pointer</li>
<li><code>kern/arch/mips/syscall/syscall.c</code></li>
</ul>
<p>See <code>kern/arch/mips/locore/trap.c</code></p>
<p><strong>One important thing</strong>: when exception raised, one of the first thing <code>common_exception</code> does it to disable the interrupt on CPU. When we call <code>mips_trap</code>, interrupt exceptions are off for now.</p>
<ul class="list">
<li>If it was actually an interrupt, they stay off until  the hardware has been handled.</li>
<li>If not, don&#39;t have to call <code>mainbus_interrupt</code> to handle it, then we are ok to be interrupted again. It is not hardware interrupt, then we take interrupt exceptions back on.</li>
</ul>
<p><strong>increase program counter</strong>: if we don&#39;t do this, the system call exception will be raised over and over again. We are halting execution and doing sth else, thus we need manully. 4 byte.</p>
<p>Kernel is just a program, a sequence of instructions.</p>
<p>Two type of calls:</p>
<ul class="list">
<li>procedure calls: used by apps to execute other application code,</li>
<li>sys calls: exec kernel code.</li>
</ul>
<h2 id="multiprocessing"><a class="header-link" href="#multiprocessing"></a>Multiprocessing</h2>
<ul class="list">
<li>The OS ensures that <em>processes are isolated from one another</em>.</li>
<li>Interprocess communication should be possible.</li>
</ul>
<p>Keep in mind, it&#39;s not processes that run. Threads execute. Process has to have a thread in order to execute, so we really are talking about multithreads. Now we have a pool of threads, which belong to different processes. Only when quantum expires, we do context switch. (Timer interrupt)</p>
<h2 id="stack-diagrams"><a class="header-link" href="#stack-diagrams"></a>Stack Diagrams</h2>
<p>In the next few minutes, I&#39;m gonna show you stack diagrams because you&#39;d better bet they are going to show up on your exams.</p>
<p><code>mips_trap</code>&#39;s job is to figure out what kind of exception that actually raised. Then call the handler that is specific to this exception. Now we are going to execute <code>mips_trap</code>. Now after we check that if it&#39;s an interrupt or not, then it realizes that it is not an interrupt, then <code>mips_trap</code> will turn exceptions and interrupts back on. It means that while we are executing our sys call, we CAN be interrupted. KEEP THAT IN MIND.</p>
<p>Look at <code>v0</code> and that&#39;s going to tell you which syscal we actually want to run (a great big old <code>switch</code> statement). We want <code>sys_fork</code>. Now interrupts are on which means you can be preempted while executed this fork.</p>
<p>So now what happens to our stack: If we have a timer interrupt. First thing you see is trap frame (produced by <code>common_exception</code>). Push a trapframe onto the kernel stack. Since we are already in privilege mode and on kernel stack, you actually know the <code>common_exception</code> code. If we are on kernel stack, we don&#39;t do anything but just save the trapframe right. Then call <code>mips_trap</code> to figure out what just happened. It&#39;s <code>mainbus_interrupt</code>. It&#39;s hardware interrupt. While they are handling interrupts from hardware, we don&#39;t want to handle other hardware interrupts because this is the behaviour that is outside the control that thread is running and we don&#39;t to disrupt it for too long so generally leave it off.</p>
<p>In <code>mainbus_interrupt</code>, we discover it&#39;s the clock. Call interrupt handler for the clock: exceed schedule quantum, I&#39;d better preempt you. So call <code>thread_yield</code> -&gt; <code>thread_switch</code> -&gt; <code>switch_frame</code>. Context switch occurs. Popping off the stack, then returns to ... Then go back to <code>common_exception</code> where we restore the trapframe. Btw, we are turning the interrupts back on. Then back to user stack, reset the CPU back to unprivileged mode and now we go back to have a process to thread running its regular user mode. Similar to multithreads, but we have two stacks.</p>
<p>Now suppose we don&#39;t have interrupt. Return to syscall. At the very end of syscall, set return value and success/failure values for that system. Zero: success; One: failure. The last thing in syscall dispatcher（调度）, <strong>increment program counter</strong> because when the exception is raised we didn&#39;t actually increment it.</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> (err) { <span class="hljs-comment">/* err */</span>
    tf-&gt;tf_v0 = err;
    tf-&gt;tf_a3 = <span class="hljs-number">1</span>;
} <span class="hljs-keyword">else</span> { <span class="hljs-comment">/* no err */</span>
    tf-&gt;tf_v0 = retval;
    tf-&gt;tf_a3 = <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* advance PC */</span>
tf-&gt;tf_epc += <span class="hljs-number">4</span>;</code></pre><p><code>mips_trap</code> returns to <code>common_exception</code>. The trapframe data is
restored. Switch from kernel to user stack. Switch to unprivileged
mode (<code>rfe</code>: magical instruction). User code continues execution.</p>
<ul class="list">
<li>These diagrams are always on either midterm or final.</li>
<li>It is not possible for you to have two track frames back-to-back in OS/161. Reason for that is because when the exception is raised at the CPU, interrupts are turned off and they do not come back on again until at least halfway through <code>mips_trap</code> which means that each trapframe must be separated by at least <code>mips_trap</code>.</li>
</ul>
<h2 id="inter-process-communication-(ipc)"><a class="header-link" href="#inter-process-communication-(ipc)"></a>Inter-Process Communication (IPC)</h2>
<p>Processes can talk to each other. IPC is a family of methods used to send data between processes.</p>
<p>File, Socket, Pipe, Shared Memory, Message Passing/Queue.</p>
<hr>
<p>Lec 11 ...</p>
<!--end-->
</div>
