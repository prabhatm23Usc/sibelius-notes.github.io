---
title: CS 350 - Operating Systems
layout: markdown
---

<div class="content">

<h1>CS 350 - Operating Systems</h1>

<div class="md-toc content">
    <p class="md-toc-content">
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#execv">execv</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#system-calls">System Calls</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#user-and-kernel-stacks">User and Kernel Stacks</a>
    </span>
    </p>
</div>


<!--start--><p>miscellaneous notes...</p>
<h1 id="execv"><a class="header-link" href="#execv"></a>execv</h1>
<p>Now, the last of the five system calls: execv. It does not create a new process.</p>
<p>It changes the program and a existing process is running. Process structure is same, but the address space has changed.</p>
<p><code>Hello world</code> program, and call <code>execv matlab</code>.</p>
<p>Create a new address space, and load the program into the new address space.</p>
<p>Parent child relationship: If you go home tonight, and dye your hair in green, your parent may not like it. But they cannot change genetically they are your parents. The same is true for processes: you can change the program that you are running but you cannot change parent-child relationship.</p>
<p>Example from slides:</p>
<pre class="hljs"><code><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span>
</span>{
    <span class="hljs-keyword">int</span> rc = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">char</span> *args[<span class="hljs-number">4</span>];

    args[<span class="hljs-number">0</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"/testbin/argtest"</span>;
    args[<span class="hljs-number">1</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"first"</span>;
    args[<span class="hljs-number">2</span>] = (<span class="hljs-keyword">char</span> *) <span class="hljs-string">"second"</span>;
    args[<span class="hljs-number">3</span>] = <span class="hljs-number">0</span>; <span class="hljs-comment">// null terminator</span>

    rc = execv(<span class="hljs-string">"/testbin/argtest"</span>, args); <span class="hljs-comment">// takes two parameters</span>
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"If you see this execv failed\n"</span>);
    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"rc = %d errno = %d\n"</span>, rc, errno);
    <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
}</code></pre><p>takes two parameters. Many times you need command line arguments. Array of pointers.</p>
<p><code>execv</code> if it succeeds, does not return. Because it successfully created the new address space and new program. We successfully loaded the program into it. The calling program will not exist if <code>execv</code> succeeded. The only time it returns is when it fails. Why would it fail? 30mb ram then run Matlab. It&#39;s possible that there&#39;s no memory left or you call the program wrongly. When you write your <code>execv</code>, you need to test for these error cases and return appropriate error codes. (but cs350 stuff don&#39;t have such tests on these).</p>
<p>You notice that we can&#39;t tell how many arguments there are automatically. So we use null terminator array and you are responsible for counting.</p>
<p>Another example. This time with fork.</p>
<pre class="hljs"><code>main()
{
    <span class="hljs-keyword">char</span> *args[<span class="hljs-number">4</span>];
    <span class="hljs-comment">/* set args here */</span>
    rc = fork(); <span class="hljs-comment">/* returns 0 to child, pid to parent */</span>
    <span class="hljs-keyword">if</span> (rc == <span class="hljs-number">0</span>) {
        status = execv(<span class="hljs-string">"/testbin/argtest"</span>,args);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"If you see this execv failed\n"</span>);
        <span class="hljs-built_in">printf</span>(<span class="hljs-string">"status = %d errno = %d\n"</span>, status, errno);
        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);
    } <span class="hljs-keyword">else</span> {
        child_pid = rc;
        parent_code();
        p = waitpid(child_pid,&amp;child_exit,<span class="hljs-number">0</span>);
    }
}</code></pre><p>Now I have two processes. Even though they are separate, but their contents are identical with the exception of value of <code>rc</code>. 0 for child, pid for parent.</p>
<p>If child, <code>execv</code>. Child is running different process. Parent can still wait for child to terminate. Parent child relationship is not impacted by <code>execv</code> which stays forever.</p>
<p>Go home and write thread fork bomb.</p>
<h1 id="system-calls"><a class="header-link" href="#system-calls"></a>System Calls</h1>
<ul class="list">
<li>Process management calls, e.g., fork, are called by user programms. They are also system calls.</li>
<li><strong>System calls</strong> are the interface between user processes and the kernel.</li>
<li>The kernel code runs at the highest privilege level, where any CPU instructions can be executed.</li>
<li>Program in user space cannot execute code or instructions belonging to a higher-level of privilege.</li>
</ul>
<p><strong>Key Question</strong>: Since application programs cannot directly call the
kernel, how does a program make a system call such as <code>fork</code>?</p>
<ol class="list">
<li>Interrupts<ul class="list">
<li>Interrupts are raised by devices (hardware)</li>
<li>An interrupt causes the CPU to transfer control to a fixed location in memory (specified by the designers of the CPU) where an interrupt handler must be located.</li>
<li>Interrupt handlers are part of the kernel.</li>
</ul>
</li>
<li>Exceptions<ul class="list">
<li>conditions that occur during the execution of a program instruction.</li>
<li>The CPU handles exceptions like it handles interrupts:<ul class="list">
<li>Control is transferred to a fixed location, where an exception handler is located.</li>
<li>The processor switches to privileged execution mode.</li>
</ul>
</li>
<li>In OS/161 <em>the same routine is used to handle exceptions and interrupts</em>.</li>
</ul>
</li>
</ol>
<p><strong>Key Question</strong>: There is only one <code>syscall</code> exception, <code>EX_SYS</code>. So how does the OS distinguish between a <code>fork</code> and <code>getpid</code> system call?</p>
<p>system call codes</p>
<h2 id="user-and-kernel-stacks"><a class="header-link" href="#user-and-kernel-stacks"></a>User and Kernel Stacks</h2>
<p>Every OS/161 process thread has two stacks, although it only uses one at a time.</p>
<ol class="list">
<li>The User (Application) Stack is used while the thread is executing application code.<ul class="list">
<li>Saw this in <a href="/19-05/CS241/">CS 241</a>.</li>
<li>The kernel creates this stack when it sets up the virtual address space for the process (or thread if the OS supports multi-threaded code).</li>
</ul>
</li>
<li>The Kernel Stack is used while the thread is executing kernel code, i.e. after an exception or interrupt.<ul class="list">
<li>This stack is a kernel structure (i.e. it is located in the kernelâ€™s address space).</li>
<li>It also holds trap frames and switch frames (because it is the kernel that creates trap frames and switch frames)</li>
</ul>
</li>
</ol>
<!--end-->
</div>
