---
title: CS 341 - Algorithms (midterm)
layout: markdown
---

<div class="content">

<h1>CS 341 - Algorithms (midterm)</h1>

<div class="md-toc content">
    <p class="md-toc-content">
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#pre">Pre</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#reduction">Reduction</a>
    </span>
    <span class="md-toc-item md-toc-h3">
        <a class="md-toc-inner" href="#3-sum">3-sum</a>
    </span>
    <span class="md-toc-item md-toc-h3">
        <a class="md-toc-inner" href="#target3sum">target3sum</a>
    </span>
    <span class="md-toc-item md-toc-h3">
        <a class="md-toc-inner" href="#3array3sum">3array3SUM</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#terminology">Terminology</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#loop-analysis">Loop Analysis</a>
    </span>
    <span class="md-toc-item md-toc-h1">
        <a class="md-toc-inner" href="#divide-and-conquer">Divide and Conquer</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#recursion">Recursion</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#the-d&amp;c-design-strategy">The D&amp;C design strategy</a>
    </span>
    <span class="md-toc-item md-toc-h2">
        <a class="md-toc-inner" href="#examples">Examples</a>
    </span>
    </p>
</div>


<!--start--><p>Check my <a href="../cs341">scattered notes</a></p>
<h1 id="pre"><a class="header-link" href="#pre"></a>Pre</h1>
<p><strong>Algorithm</strong>: effective unambiguous finite</p>
<p><strong>solve a problem</strong>: Every instance I of problem P, when alg runs, it outputs a valid soln to P.</p>
<ul class="list">
<li><strong>Line-code model</strong>: Each line takes 1 time step.</li>
<li><strong>Bit-cost model</strong>: single bit take 1 step.</li>
</ul>
<p>Neither is ideal.</p>
<p><strong>Word Ram model</strong>: The Word RAM model is the computational model
in which for an algorithm run on an input of size \(n\),</p>
<ul class="list">
<li>the memory of the algorithm is broken up into words of length \(w=\log n\), and</li>
<li>any elementary operation (read, write, add, multiply, AND, etc.) on any single word
in memory takes 1 time step.</li>
</ul>
<p>Big \(O, \Omega, \Theta\) notation.</p>
<p>little-\(o,\omega\).
\[
\lim_{n\to\infty} {f(n)\over g(n)}=0 \implies f=o(g)
\]</p>
<h2 id="reduction"><a class="header-link" href="#reduction"></a>Reduction</h2>
<p><strong>Idea</strong>: Use known algs to solve new problems.</p>
<h3 id="3-sum"><a class="header-link" href="#3-sum"></a>3-sum</h3>
<p>sum 3 distinct = 0</p>
<p>Trivial3Sum \(O(n^3)\)</p>
<p>Improved3Sum: sort, then binary search \(-B_i-B_j\). \(O(n\log n+n^2\log n)=O(n^2\log n)\).</p>
<p>Quadratic3Sum:</p>
<ul class="list">
<li>sort</li>
<li>given \(B[i]\), simultaneously scan from both ends of \(A\) looking for \(B[j] + B[k] = -B[i]\).</li>
<li>start wit \(j=i+1\) and \(k=n\)</li>
<li>\(O(n\log n+n^2)=O(n^2)\)</li>
</ul>
<h3 id="target3sum"><a class="header-link" href="#target3sum"></a>target3sum</h3>
<p>sum 3 distinct = T</p>
<p>\[
(A[i]-T/3)+(A[j]-T/3)+(A[k]-T/3)=0
\]</p>
<p>Then let \(B[i]=A[i]-T/3\).</p>
<h3 id="3array3sum"><a class="header-link" href="#3array3sum"></a>3array3SUM</h3>
<p>three arrays of \(n\) distinct integers, one from each \(A,B,C\) whose sum equals 0.</p>
<p>color them:
\[
\left \{
\begin{array}{l}
D[i]\gets 10A[i]+1\\
E[i]\gets 10B[i]+2\\
F[i]\gets 10C[i]-3
\end{array}\right.
\]</p>
<p>To show ... is a reduction, we show that \(\alpha\) is a solution to instance \(A&#39;\) <strong>if and only if</strong> \(\alpha&#39;\) is a solution to \(A\) of ... .</p>
<h2 id="terminology"><a class="header-link" href="#terminology"></a>Terminology</h2>
<p><strong>Running time</strong> can only be determined by implementing a program and
running it on a specic computer.</p>
<p>Running time is influenced by many factors, including the programming
language, processor, operating system, etc.</p>
<p><strong>Complexity</strong> (AKA growth rate) can be analyzed by high-level
mathematical analysis. It is independent of the above-mentioned factors
aecting running time.</p>
<h2 id="loop-analysis"><a class="header-link" href="#loop-analysis"></a>Loop Analysis</h2>
<ol class="list">
<li>Theta-bounds throughout the analysis</li>
<li>O and Omega separately</li>
</ol>
<p><strong>unit cost model</strong>: where we assume that
arithmetic operations such as \(+,-,\times\) and integer division take time \(\Theta(1)\).</p>
<p>If we want to consider the complexity of arithmetic operation on integers
of arbitrary size, we need to consider <strong>bit complexity</strong>, where we express the
complexity as a function of the length of the integers (as measured in bits).</p>
<h1 id="divide-and-conquer"><a class="header-link" href="#divide-and-conquer"></a>Divide and Conquer</h1>
<h2 id="recursion"><a class="header-link" href="#recursion"></a>Recursion</h2>
<p>Recursion is a special type of reduction, where we reduce the original problem to the same problem, but on a smaller input.</p>
<p>guess-and-check and recursion tree method.</p>
<p>Use recursion tree, we propose master theorem:
\(a\ge 1, b&gt; 1\). Consider the recurrence
\[T(n)=aT\left({n\over b}\right) + \Theta(n^y)\]
where n is a power of b.</p>
<p>Denote \(x=\log_b a\). Then
\[
T(n)\in
\begin{cases}
\Theta(n^x) &amp; \text{if}~y&lt;x \\
\Theta(n^x\log n) &amp; \text{if} ~y=x \\
\Theta(n^y) &amp; \text{if}~y&gt;x.
\end{cases}
\]</p>
<p>\(y&lt;x\): <strong>heavy leaves</strong>: the value of the recursion tree is dominated by
the values of the leaf nodes.</p>
<p><strong>balanced</strong>: the values of the levels of the recursion tree are
constant (except for the last level).</p>
<p><strong>heavy top</strong>: the value of the recursion tree is dominated by the
value of the root node.</p>
<h2 id="the-d&c-design-strategy"><a class="header-link" href="#the-d&c-design-strategy"></a>The D&amp;C design strategy</h2>
<p><strong>divide</strong>: Given a problem instance \(I\), construct one or more smaller
problem instances, denoted \(I_1, \ldots I_a\) (these are called subproblems).</p>
<p><strong>conquer</strong>: For \(1\le j \le a\), solve instance \(I_j\) recursively, obtain solutions \(S_1,\ldots,S_a\).</p>
<p><strong>combine</strong>: Given \(S_1,\ldots,S_a\), use an appropriate combining function to find the solution \(S\) to the problem instance \(I\).</p>
<p>sloppy and exact recurrence.</p>
<h2 id="examples"><a class="header-link" href="#examples"></a>Examples</h2>
<p>Non-dominated Points: Find all the points that are not dominated by any other point</p>
<p>Closest Pair: Euclidean distance of two points is minimized. Using strip area: \(\delta=\min{\delta_L,\delta_R}\). And search in rectangle of \(2\delta\times\delta\).</p>
<p>Fase Matrix Multiplication.</p>
<!--end-->
</div>
