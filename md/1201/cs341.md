---
title: CS 341 - Algorithms
layout: mdtoc
---
post mid material: starting from graph algorithms. Notes are a mix of different offerings...

# Graph Algorithms
## Basic
directed, adjacent, incident, indegree, outdegree, path, cycle, tree, connected, connected component.

A **simple** path does not repeat vertices. A **simple** cycle does not repeat vertices.


Our algorithms will be for abstract graphs. Two ways to represent:
- adjacency matrix: space &#92;(O(n^2) &#92;)
- adjacency lists: space &#92;(O(n+m) &#92;)

|basic operations  | adj matrix| adj lists|
| :------------- | :------------- | :-- |
| list &#92;(v &#92;)'s neighbours| &#92;(\Theta(n) &#92;) | &#92;(\Theta(1+\deg(v)) &#92;)|
| list all edges | &#92;(\Theta(n^2) &#92;) | &#92;(\Theta(n+m) &#92;) |
| is &#92;((u,v)\in E &#92;) | &#92;(\Theta(1) &#92;) | &#92;(\Theta(1+\deg(u)) &#92;) |

where the last complexity &#92;(\Theta(1+\deg(u)) &#92;)  can be reduced to &#92;(O(1) &#92;)
with (sophisiticated) hashing.

For algorithm in this course, we will use adjacency lists.

## Exploring Graphs

### BFS
Cautious search: check everything one edge away, then two...

It takes &#92;(O(n+m) &#92;) time: we explore each vertex once and check all incident edges: &#92;(O(n+\sum_{v\in V} \deg(v))=O(n+m) &#92;). Recall &#92;(\sum_{v\in V} \deg(v) = 2m &#92;).

**Properties**
- The parent pointers create a directed tree.
- &#92;(u &#92;) is connected to &#92;(v_0 &#92;) iff BFS from &#92;(v_0 &#92;) reaches &#92;(u &#92;).
- The level of a vertex &#92;(v &#92;) = length of shortest path from &#92;(v_0 &#92;) to &#92;(v &#92;).

**Consequences**
1. BFS from &#92;(v_0 &#92;) finds the connected component of &#92;(v_0 &#92;)
2. BFS finds shortest paths (# edges) from &#92;(v_0 &#92;)

**BFS to test bipartiteness**
definition omitted... it cannot have an odd cycle.

### DFS
Bold search: go as far as you can; when there's nothing new to discover, retrace your steps to find sth new.

Note: orders depend on order in adjacency list. Use a stack to store vertices that have been discovered but must still be explored. So we use a recursive algorithm where stack is implicit.

Runtime: &#92;(O(n+m) &#92;)

All non-tree edges join ancestor and descendant.

Here we abbr: &#92;(d(v)=discovers(v), f(v)=finish(v) &#92;). If &#92;(d(v)<d(u) &#92;) then we have only two possiblities: either nested or disjoint
```
[       ]       [       ]           OR [        [       ]       ]
d(v)    f(v)    d(u)    f(u)           d(v)     d(u)    f(u)    f(v)
```
because interval &#92;(d(v),f(v) &#92;) is time on stack.

**DFS to find 2-connected components**. Involve some defns of cut-vertex. Not covered in
